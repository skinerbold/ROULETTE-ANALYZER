'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { 
  RouletteNumber, 
  RouletteMessage,
  RouletteInfo,
  WEBSOCKET_CONFIG,
  getRouletteColor,
  parseRouletteName
} from '@/lib/roulette-websocket'

export interface UseRouletteWebSocketReturn {
  isConnected: boolean
  lastNumber: RouletteNumber | null
  recentNumbers: RouletteNumber[]
  error: string | null
  reconnectAttempts: number
  availableRoulettes: RouletteInfo[]
  selectedRoulette: string
  updateVersion: number // NOVO: for√ßa re-render
  connect: () => void
  disconnect: () => void
  sendMessage: (message: string) => void
  selectRoulette: (rouletteId: string) => void
}

export function useRouletteWebSocket(): UseRouletteWebSocketReturn {
  const [isConnected, setIsConnected] = useState(false)
  const [lastNumber, setLastNumber] = useState<RouletteNumber | null>(null)
  const [recentNumbers, setRecentNumbers] = useState<RouletteNumber[]>([])
  const [error, setError] = useState<string | null>(null)
  const [reconnectAttempts, setReconnectAttempts] = useState(0)
  const [availableRoulettes, setAvailableRoulettes] = useState<RouletteInfo[]>([])
  const [selectedRoulette, setSelectedRoulette] = useState<string>('')
  const [updateVersion, setUpdateVersion] = useState(0)
  
  const wsRef = useRef<WebSocket | null>(null)
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const isIntentionalCloseRef = useRef(false)
  const discoveredRoulettesRef = useRef<Set<string>>(new Set())
  const rouletteHistoryRef = useRef<Map<string, RouletteNumber[]>>(new Map())
  const selectedRouletteRef = useRef<string>('') // REF para valor sempre atualizado

  // Limpar timeouts
  const clearTimeouts = useCallback(() => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current)
      heartbeatIntervalRef.current = null
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }
  }, [])

  // Iniciar heartbeat (manter conex√£o viva)
  const startHeartbeat = useCallback(() => {
    clearTimeouts()
    heartbeatIntervalRef.current = setInterval(() => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: 'ping' }))
      }
    }, WEBSOCKET_CONFIG.heartbeatInterval)
  }, [clearTimeouts])

  // Processar mensagens recebidas
  const handleMessage = useCallback((data: string) => {
    try {
      // Tentar parsear como JSON
      const message: any = JSON.parse(data)
      
      // Verificar se √© o formato da API real (game, key, game_type, results)
      if (message.game && message.game_type === 'roleta' && Array.isArray(message.results)) {
        const rouletteId = message.game
        
        // üî• FILTRO CR√çTICO: Ignorar mensagens de roletas N√ÉO selecionadas
        // Isso evita que mensagens de outras roletas "contaminem" a tela
        const isSelected = rouletteId === selectedRouletteRef.current
        
        if (!isSelected && selectedRouletteRef.current !== '') {
          // J√° temos uma roleta selecionada E esta mensagem √© de outra roleta
          console.log(`üö´ [${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 })}] Mensagem IGNORADA de roleta n√£o selecionada: ${rouletteId}`)
          console.log(`   Selecionada: ${selectedRouletteRef.current}`)
          console.log(`   Mensagem de: ${rouletteId}`)
          
          // Salvar no hist√≥rico interno para quando o usu√°rio selecionar essa roleta
          // MAS N√ÉO ATUALIZAR O ESTADO REACT!
          const numbersFromAPI = message.results
            .map((r: any) => parseInt(r))
            .filter((n: number) => !isNaN(n) && n >= 0 && n <= 37)
            .slice(0, WEBSOCKET_CONFIG.maxHistorySize)
          
          if (numbersFromAPI.length > 0) {
            const now = Date.now()
            const history: RouletteNumber[] = numbersFromAPI.map((num: number, index: number) => ({
              number: num,
              color: getRouletteColor(num),
              timestamp: now - (index * 60000)
            }))
            rouletteHistoryRef.current.set(rouletteId, history)
          }
          
          // IMPORTANTE: Adicionar √† lista de roletas dispon√≠veis (se for nova)
          if (!discoveredRoulettesRef.current.has(rouletteId)) {
            discoveredRoulettesRef.current.add(rouletteId)
            const newRouletteInfo = parseRouletteName(rouletteId)
            setAvailableRoulettes(prev => {
              const exists = prev.some(r => r.id === rouletteId)
              if (!exists) {
                const updated = [...prev, newRouletteInfo].sort((a, b) => a.name.localeCompare(b.name))
                console.log(`   üìã Adicionada √† lista (total: ${updated.length})`)
                return updated
              }
              return prev
            })
          }
          
          return // PARAR AQUI - n√£o processar mais nada
        }
        
        // LOG: Mostrar TODAS as mensagens com timestamp preciso
        const timestamp = new Date().toLocaleTimeString('pt-BR', { 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit', 
          fractionalSecondDigits: 3 
        })
        
        if (isSelected) {
          console.log(`\nüî•üî•ÔøΩ [${timestamp}] MENSAGEM DA ROLETA SELECIONADA: ${rouletteId}`)
          console.log(`   üì¶ Dados COMPLETOS da API:`, JSON.stringify(message, null, 2))
          console.log(`   üé≤ Primeiros 15 n√∫meros: [${message.results.slice(0, 15).join(', ')}]`)
          console.log(`   üìä Total de n√∫meros: ${message.results.length}`)
          console.log(`   üîë Message keys:`, Object.keys(message))
        } else {
          // Log de mensagens de outras roletas (resumido)
          console.log(`üì≠ [${timestamp}] Mensagem de outra roleta: ${rouletteId} (${message.results.length} n√∫meros)`)
        }
        
        // Adicionar roleta descoberta √† lista
        if (!discoveredRoulettesRef.current.has(rouletteId)) {
          discoveredRoulettesRef.current.add(rouletteId)
          
          // Atualizar lista de roletas
          const newRouletteInfo = parseRouletteName(rouletteId)
          setAvailableRoulettes(prev => {
            const exists = prev.some(r => r.id === rouletteId)
            if (!exists) {
              const updated = [...prev, newRouletteInfo].sort((a, b) => 
                a.name.localeCompare(b.name)
              )
              console.log(`\nüé∞ üé∞ üé∞ NOVA ROLETA DESCOBERTA!`)
              console.log(`   üÜî ID: ${rouletteId}`)
              console.log(`   üìõ Nome: ${newRouletteInfo.name}`)
              console.log(`   üè¢ Provedor: ${newRouletteInfo.provider || 'N/A'}`)
              console.log(`   üìä Total de roletas dispon√≠veis: ${updated.length}`)
              console.log(`   üìã Lista completa:`, updated.map(r => r.id))
              return updated
            }
            return prev
          })
        }
        
        // Converter results (strings) para n√∫meros
        const numbersFromAPI = message.results
          .map((r: any) => {
            const parsed = parseInt(r)
            if (isNaN(parsed)) {
              console.warn(`‚ö†Ô∏è N√∫mero inv√°lido recebido: "${r}" em ${rouletteId}`)
            }
            return parsed
          })
          .filter((n: number) => !isNaN(n) && n >= 0 && n <= 37) // 0-36 + 37 (00)
          .slice(0, WEBSOCKET_CONFIG.maxHistorySize)
        
        if (numbersFromAPI.length === 0) {
          console.warn(`‚ö†Ô∏è Nenhum n√∫mero v√°lido recebido de ${rouletteId}`)
          return
        }
        
        // Obter hist√≥rico atual desta roleta
        const currentHistory = rouletteHistoryRef.current.get(rouletteId) || []
        
        // Se n√£o h√° hist√≥rico, inicializar com TODOS os n√∫meros da API
        if (currentHistory.length === 0) {
          const now = Date.now()
          const history: RouletteNumber[] = numbersFromAPI.map((num: number, index: number) => ({
            number: num,
            color: getRouletteColor(num),
            timestamp: now - (index * 60000) // Aproxima√ß√£o de timestamps
          }))
          
          rouletteHistoryRef.current.set(rouletteId, history)
          
          // Se esta roleta estiver selecionada, atualizar estado
          if (rouletteId === selectedRoulette) {
            // FOR√áA atualiza√ß√£o com spread operator
            setRecentNumbers([...history])
            if (history.length > 0) {
              setLastNumber({...history[0]})
            }
            setUpdateVersion(v => v + 1) // Incrementar vers√£o
            console.log(`üìú [SELECIONADA] Inicializado ${rouletteId}: ${history.length} n√∫meros - [${history.slice(0, 5).map(n => n.number).join(', ')}...]`)
          }
          return
        }
        
        // SINCRONIZA√á√ÉO COMPLETA: Comparar arrays inteiros
        // A API sempre envia o hist√≥rico completo atualizado
        const currentNumbers = currentHistory.map(h => h.number)
        const areEqual = currentNumbers.length === numbersFromAPI.length && 
                        currentNumbers.every((n, i) => n === numbersFromAPI[i])
        
        // LOG para debug: mostrar resultado da compara√ß√£o
        if (isSelected) {
          console.log(`   üîç Compara√ß√£o de arrays:`)
          console.log(`      Atual: [${currentNumbers.slice(0, 10).join(', ')}...] (${currentNumbers.length})`)
          console.log(`      Nova:  [${numbersFromAPI.slice(0, 10).join(', ')}...] (${numbersFromAPI.length})`)
          console.log(`      Arrays iguais? ${areEqual}`)
        }
        
        if (!areEqual) {
          // Houve mudan√ßa! Reconstruir hist√≥rico completo
          const now = Date.now()
          const isNewSpin = currentNumbers[0] !== numbersFromAPI[0]
          
          console.log(`\nüîç [DEBUG] Detectada mudan√ßa em ${rouletteId}:`)
          console.log(`   Atual (${currentNumbers.length}): [${currentNumbers.slice(0, 10).join(', ')}]`)
          console.log(`   Nova  (${numbersFromAPI.length}): [${numbersFromAPI.slice(0, 10).join(', ')}]`)
          console.log(`   √â novo spin? ${isNewSpin}`)
          console.log(`   Est√° selecionada? ${rouletteId === selectedRouletteRef.current}`) // USAR REF!
          
          const updatedHistory: RouletteNumber[] = numbersFromAPI.map((num: number, index: number) => {
            // Para o primeiro n√∫mero (se for novo spin), usar timestamp atual
            if (index === 0 && isNewSpin) {
              return {
                number: num,
                color: getRouletteColor(num),
                timestamp: now
              }
            }
            
            // Para os outros, manter timestamp existente se estiver na mesma posi√ß√£o
            const existingAtSamePosition = currentHistory[index]
            if (existingAtSamePosition && existingAtSamePosition.number === num) {
              // Mesmo n√∫mero na mesma posi√ß√£o = manter timestamp
              return {
                number: num,
                color: getRouletteColor(num),
                timestamp: existingAtSamePosition.timestamp
              }
            }
            
            // N√∫mero diferente ou posi√ß√£o nova = timestamp estimado
            return {
              number: num,
              color: getRouletteColor(num),
              timestamp: now - (index * 60000) // Aproxima√ß√£o
            }
          })
          
          // Salvar no hist√≥rico
          rouletteHistoryRef.current.set(rouletteId, updatedHistory)
          
          // Se esta roleta estiver selecionada, atualizar estado SEMPRE
          if (rouletteId === selectedRouletteRef.current) { // USAR REF!
            const timestampUpdate = new Date().toLocaleTimeString('pt-BR', { 
              hour: '2-digit', 
              minute: '2-digit', 
              second: '2-digit', 
              fractionalSecondDigits: 3 
            })
            
            console.log(`\n‚ö°‚ö°‚ö° [${timestampUpdate}] ATUALIZANDO ESTADO REACT`)
            console.log(`   üé∞ Roleta: ${rouletteId}`)
            console.log(`   üìä ANTES - n√∫meros na tela: [${recentNumbers.slice(0, 10).map(n => n.number).join(', ')}...]`)
            console.log(`   üìä DEPOIS - novos n√∫meros: [${updatedHistory.slice(0, 10).map(n => n.number).join(', ')}...]`)
            console.log(`   üî¢ Quantidade: ${recentNumbers.length} ‚Üí ${updatedHistory.length}`)
            console.log(`   üÜï √â novo spin? ${isNewSpin}`)
            
            // FOR√áA atualiza√ß√£o criando novo array com spread
            setRecentNumbers([...updatedHistory])
            
            if (updatedHistory.length > 0) {
              setLastNumber({...updatedHistory[0]}) // Clone do objeto para for√ßar update
            }
            
            setUpdateVersion(v => v + 1)
            
            console.log(`   ‚úÖ setRecentNumbers e setUpdateVersion chamados\n`)
          }
        }
        
        return
      }
      
      // Se n√£o for formato da API real, mostrar detalhes da mensagem
      console.log('‚ö†Ô∏è MENSAGEM IGNORADA (formato desconhecido)')
      console.log('   üì¶ Tipo:', typeof message)
      console.log('   üîë Keys:', Object.keys(message))
      console.log('   üìÑ Conte√∫do:', JSON.stringify(message).substring(0, 200))
    } catch (err) {
      // Ignorar mensagens que n√£o s√£o JSON v√°lido
      console.log('‚ÑπÔ∏è Mensagem n√£o-JSON ignorada:', typeof data === 'string' ? data.substring(0, 100) : data)
    }
  }, []) // REMOVIDO selectedRoulette - agora usa REF!

  // Tentar reconectar
  const attemptReconnect = useCallback(() => {
    if (isIntentionalCloseRef.current) {
      console.log('‚èπÔ∏è Reconex√£o cancelada (fechamento intencional)')
      return
    }

    if (reconnectAttempts >= WEBSOCKET_CONFIG.maxReconnectAttempts) {
      setError(`Falha ao conectar ap√≥s ${WEBSOCKET_CONFIG.maxReconnectAttempts} tentativas`)
      console.error('‚ùå M√°ximo de tentativas de reconex√£o atingido')
      return
    }

    console.log(`üîÑ Tentando reconectar... (Tentativa ${reconnectAttempts + 1}/${WEBSOCKET_CONFIG.maxReconnectAttempts})`)
    
    reconnectTimeoutRef.current = setTimeout(() => {
      setReconnectAttempts(prev => prev + 1)
      connect()
    }, WEBSOCKET_CONFIG.reconnectInterval)
  }, [reconnectAttempts])

  // Conectar ao WebSocket
  const connect = useCallback(() => {
    // Evitar m√∫ltiplas conex√µes
    if (wsRef.current?.readyState === WebSocket.OPEN || 
        wsRef.current?.readyState === WebSocket.CONNECTING) {
      console.log('‚ö†Ô∏è J√° existe uma conex√£o ativa')
      return
    }

    try {
      console.log('üîå Conectando ao WebSocket:', WEBSOCKET_CONFIG.url)
      
      const ws = new WebSocket(WEBSOCKET_CONFIG.url)
      wsRef.current = ws

      ws.addEventListener('open', () => {
        console.log('‚úÖ ‚úÖ ‚úÖ CONECTADO AO SERVIDOR WebSocket!')
        console.log('   üåê URL:', WEBSOCKET_CONFIG.url)
        console.log('   üîó ReadyState:', ws.readyState)
        console.log('   ‚è∞ Timestamp:', new Date().toISOString())
        
        setIsConnected(true)
        setError(null)
        setReconnectAttempts(0)
        isIntentionalCloseRef.current = false
        
        // Iniciar heartbeat
        startHeartbeat()
        
        // Opcional: solicitar hist√≥rico
        console.log('üì§ Enviando requisi√ß√£o de hist√≥rico...')
        ws.send(JSON.stringify({ type: 'get_history' }))
      })

      ws.addEventListener('message', (event) => {
        console.log('\nüì® üì® üì® MENSAGEM RECEBIDA DO WEBSOCKET:')
        console.log('   üìè Tamanho:', event.data.length, 'caracteres')
        console.log('   üìÑ Preview:', typeof event.data === 'string' ? event.data.substring(0, 200) : event.data)
        handleMessage(event.data)
      })

      ws.addEventListener('error', (event) => {
        console.error('‚ùå ‚ùå ‚ùå ERRO DE WEBSOCKET:')
        console.error('   üî¥ Event:', event)
        console.error('   üîó URL tentada:', WEBSOCKET_CONFIG.url)
        console.error('   üîó ReadyState:', ws.readyState)
        setError('Erro na conex√£o WebSocket')
      })

      ws.addEventListener('close', (event) => {
        console.log(`üîå Conex√£o fechada. C√≥digo: ${event.code}, Motivo: ${event.reason}`)
        setIsConnected(false)
        clearTimeouts()
        
        // Definir mensagem de erro apropriada
        if (!isIntentionalCloseRef.current) {
          setError('üîå Conex√£o perdida. Tentando reconectar...')
          attemptReconnect()
        }
      })

    } catch (err) {
      console.error('‚ùå Erro ao criar WebSocket:', err)
      setError('N√£o foi poss√≠vel conectar ao servidor')
    }
  }, [startHeartbeat, handleMessage, attemptReconnect, clearTimeouts])

  // Desconectar do WebSocket
  const disconnect = useCallback(() => {
    console.log('üîå Desconectando do WebSocket...')
    isIntentionalCloseRef.current = true
    clearTimeouts()
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'Desconex√£o intencional')
      wsRef.current = null
    }
    
    setIsConnected(false)
  }, [clearTimeouts])

  // Enviar mensagem
  const sendMessage = useCallback((message: string) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(message)
      console.log('üì§ Mensagem enviada:', message)
    } else {
      console.warn('‚ö†Ô∏è WebSocket n√£o est√° conectado')
    }
  }, [])

  // Fun√ß√£o para selecionar roleta
  const selectRoulette = useCallback((rouletteId: string) => {
    console.log(`üéØ Selecionando roleta: ${rouletteId}`)
    setSelectedRoulette(rouletteId)
    selectedRouletteRef.current = rouletteId // Atualizar ref IMEDIATAMENTE
    
    // Carregar hist√≥rico desta roleta
    const history = rouletteHistoryRef.current.get(rouletteId) || []
    
    // FOR√áA atualiza√ß√£o criando novo array
    setRecentNumbers([...history])
    
    if (history.length > 0) {
      setLastNumber({...history[0]})
      console.log(`   ‚úÖ ${history.length} n√∫meros carregados: [${history.slice(0, 5).map(n => n.number).join(', ')}...]`)
    } else {
      setLastNumber(null)
      console.log(`   ‚è≥ Aguardando dados...`)
    }
    
    setUpdateVersion(v => v + 1) // Incrementar vers√£o para for√ßar re-render
  }, [])

  // Conectar automaticamente ao montar
  useEffect(() => {
    connect()

    // Cleanup ao desmontar
    return () => {
      disconnect()
    }
  }, []) // Executar apenas uma vez

  // Sincronizar ref com state sempre que selectedRoulette mudar
  useEffect(() => {
    selectedRouletteRef.current = selectedRoulette
    console.log(`üîÑ [REF SYNC] selectedRouletteRef atualizada para: "${selectedRoulette}"`)
  }, [selectedRoulette])

  return {
    isConnected,
    lastNumber,
    recentNumbers,
    error,
    reconnectAttempts,
    availableRoulettes,
    selectedRoulette,
    updateVersion, // NOVO: vers√£o para for√ßar re-render
    connect,
    disconnect,
    sendMessage,
    selectRoulette
  }
}
